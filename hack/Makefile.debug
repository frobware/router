# -*- mode: makefile -*-

export GOOS=linux

REGISTRY ?= <some-registry.com>
IMAGE ?= <some-user-namespace>/openshift-router
TAG ?= latest
IMAGEBUILDER ?= podman

SERVICE_FILES := $(wildcard hack/remote-debug/*.service)
SYSTEMD_DIR   := $(HOME)/.config/systemd/user

DOCKERFILE_DEBUG ?= hack/Dockerfile.debug

# Uncomment the following for remote debugging.
# DOCKERFILE_DEBUG = hack/remote-debug/Dockerfile

ifeq ($(DOCKERFILE_DEBUG),hack/remote-debug/Dockerfile)
  # Remote debugging requires the dlv executable in the local
  # directory which is copied into the container in
  # hack/remote-debug/Dockerfile.
  ifeq (,$(wildcard ./dlv))
    $(error dlv executable not found in the current directory. Consider running ./hack/remote-debug/find-and-copy-dlv-from-goland-installation)
  endif
endif

# The `--continue` flag for `dlv` (Delve debugger) starts the debuggee
# immediately, without halting for a debugger to attach. This setup
# ensures that the router is operational from the get-go, yet still
# allows for remote debugging. Attach from your IDE at any time after
# launch to begin debugging.
DLV_CONTINUE ?= --continue

build:
	GO111MODULE=on CGO_ENABLED=0 GOFLAGS=-mod=vendor go build -o openshift-router -gcflags=all="-N -l" ./cmd/openshift-router
	GO111MODULE=on CGO_ENABLED=0 GOFLAGS=-mod=vendor go build -o hack/remote-debug/remote-debug-helper -gcflags=all="-N -l" ./hack/remote-debug/remote-debug-helper.go

hack/remote-debug/ssh:
	mkdir -p $@

hack/remote-debug/ssh/id_ed25519: | hack/remote-debug/ssh
	ssh-keygen -t ed25519 -f $@ -C "root@router" -N "" -q

# Conditionally add the SSH key pair dependency.
ifeq ($(DOCKERFILE_DEBUG),hack/remote-debug/Dockerfile)
build-image: hack/remote-debug/ssh/id_ed25519
endif

build-image: build
	$(IMAGEBUILDER) build -t $(IMAGE):$(TAG) -f $(DOCKERFILE_DEBUG) .

push-image:
	$(IMAGEBUILDER) tag $(IMAGE):$(TAG) $(REGISTRY)/$(IMAGE):$(TAG)
	$(IMAGEBUILDER) push $(REGISTRY)/$(IMAGE):$(TAG)

ifeq ($(DOCKERFILE_DEBUG),hack/remote-debug/Dockerfile)
set-image: install-port-forward-services
endif

set-image:
	oc scale --replicas 0 -n openshift-cluster-version deployments/cluster-version-operator
	oc scale --replicas 0 -n openshift-ingress-operator deployments ingress-operator
	oc scale --replicas 0 -n openshift-ingress deployment/router-default
ifeq ($(DOCKERFILE_DEBUG),hack/remote-debug/Dockerfile)
	oc apply -f hack/remote-debug/manifests
	@for patch in $(sort $(wildcard hack/remote-debug/patches/deployment/router-default/*.yaml)); do \
	    echo "Applying patch $$patch"; \
	    oc -n openshift-ingress patch deployment router-default -p "$$(cat $$patch)" --type=strategic; \
	done
endif
	oc -n openshift-ingress patch deployment router-default -p '{"spec":{"template":{"spec":{"$$setElementOrder/containers":[{"name":"router"}],"containers":[{"imagePullPolicy":"Always","name":"router"}]}}}}'
	oc -n openshift-ingress set image deployment/router-default router=$(REGISTRY)/$(IMAGE):$(TAG)
	oc scale --replicas 1 -n openshift-ingress deployment/router-default
	@echo "Waiting for the deployment/router-default to become available..."; \
	if ! oc -n openshift-ingress rollout status deployment/router-default --timeout=180s; then \
		echo "Deployment did not become available in time. Please check the deployment status."; \
		false; \
	fi
ifeq ($(DOCKERFILE_DEBUG),hack/remote-debug/Dockerfile)
	@max_attempts=10; \
	attempt=1; \
	while [ $$attempt -le $$max_attempts ]; do \
		echo "Checking SSH access..."; \
		if ssh -o ConnectTimeout=5 -F hack/remote-debug/ssh/config container uptime; then \
			echo "SSH check passed."; \
			break; \
		else \
			echo "SSH check failed. Restarting port-forward services and retrying..."; \
			$(MAKE) -f hack/Makefile.debug restart-port-forward-services; \
			attempt=$$((attempt + 1)); \
			sleep 5; \
		fi; \
	done; \
	if [ $$attempt -gt $$max_attempts ]; then \
		echo "SSH check did not pass in time. Please check the deployment and SSH configuration."; \
		false; \
	fi
endif

deploy-image: build-image push-image set-image

ifeq ($(DOCKERFILE_DEBUG),hack/remote-debug/Dockerfile)
reset:: install-port-forward-services
	$(RM) -f hack/remote-debug/ssh/id_ed25519 hack/remote-debug/ssh/id_ed25519.pub
endif

reset::
	oc scale --replicas 1 -n openshift-cluster-version deployments/cluster-version-operator
	oc scale --replicas 1 -n openshift-ingress-operator deployments ingress-operator
	oc delete -n openshift-ingress deployment/router-default
	oc delete --ignore-not-found -f hack/remote-debug/manifests

rsync-openshift-router: build
	rsync --progress --compress -e 'ssh -F hack/remote-debug/ssh/config' ./openshift-router container:/usr/bin/openshift-router

debug: rsync-openshift-router
	ssh -t -F hack/remote-debug/ssh/config container "pkill haproxy || true; /usr/bin/start-debugging $(DLV_CONTINUE)"

install-port-forward-services: | $(SYSTEMD_DIR)
	for service in $(SERVICE_FILES); do \
		install -m 644 $$service $(SYSTEMD_DIR)/$$(basename $$service); \
		systemctl --user daemon-reload; \
		systemctl --user enable --now $$(basename $$service); \
	done

uninstall-port-forward-services:
	for service in $(SERVICE_FILES); do \
		systemctl --user stop $$(basename $$service); \
		systemctl --user disable $$(basename $$service); \
		$(RM) $(SYSTEMD_DIR)/$$(basename $$service); \
		systemctl --user daemon-reload; \
	done

restart-port-forward-services:
	@for service in $(SERVICE_FILES); do \
		service_name=$$(basename $$service); \
		systemctl --user restart $$service_name; \
		if systemctl --user is-active $$service_name --quiet; then \
			echo "$$service_name is running."; \
		else \
			echo "$$service_name failed to start."; \
		fi; \
	done

$(SYSTEMD_DIR):
	@mkdir -p $@

.PHONY: ssh-container
ssh-container:
	ssh -F hack/remote-debug/ssh/config container
