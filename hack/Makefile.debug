# -*- mode: makefile -*-

export GOOS=linux

REGISTRY ?= registry.int.frobware.com
IMAGE ?= aim/openshift-router
TAG ?= latest
IMAGEBUILDER ?= podman

build:
	GO111MODULE=on CGO_ENABLED=0 GOFLAGS=-mod=vendor go build -o openshift-router -gcflags=all="-N -l" ./cmd/openshift-router

new-openshift-router-image: build
	$(IMAGEBUILDER) build -t $(IMAGE):$(TAG) -f hack/Dockerfile.remote-dev .

push:
	$(IMAGEBUILDER) tag $(IMAGE):$(TAG) $(REGISTRY)/$(IMAGE):$(TAG)
	$(IMAGEBUILDER) push $(REGISTRY)/$(IMAGE):$(TAG)

set-image:
	oc scale --replicas 0 -n openshift-cluster-version deployments/cluster-version-operator
	oc scale --replicas 0 -n openshift-ingress-operator deployments ingress-operator
	oc -n openshift-ingress scale deployment --replicas=0 router-default
	oc -n openshift-ingress patch deployment router-default -p '{"spec":{"template":{"spec":{"$$setElementOrder/containers":[{"name":"router"}],"containers":[{"imagePullPolicy":"Always","name":"router"}]}}}}'
	oc -n openshift-ingress set image deployment/router-default router=$(REGISTRY)/$(IMAGE):$(TAG)
	oc -n openshift-ingress scale deployment --replicas=1 router-default

dwim:  new-openshift-router-image push set-image

reset:
	oc scale --replicas 1 -n openshift-cluster-version deployments/cluster-version-operator
	oc scale --replicas 1 -n openshift-ingress-operator deployments ingress-operator

ROUTER_POD = $(shell oc get pods -n openshift-ingress -o=jsonpath='{.items[*].metadata.name}')

remote-debug-openshift-router-via-ssh: build
	rsync ./openshift-router container:/usr/bin/openshift-router
	ssh -t root@container dlv --listen=:7000 --api-version=2 --headless=true --accept-multiclient exec /usr/bin/openshift-router

verify:
	@echo ROUTER_POD=$(ROUTER_POD)

.PHONY: install-port-forward-services

SERVICE_FILES := oc-port-forward-2222.service oc-port-forward-7000.service
SYSTEMD_DIR   := $(HOME)/.config/systemd/user

install-port-forward-services: $(patsubst %, $(SYSTEMD_DIR)/%, $(SERVICE_FILES))

# Allow make -C hack -f Makefile.debug, or make -f Makefile.debug (in
# this directory). This rule installs the service files to the systemd
# directory and enables them. The pattern rule uses 'wildcard hack/%'
# and 'wildcard %' to locate the service files in either the 'hack'
# subdirectory or the current directory.
#
# This ensures flexibility in running the Makefile from different
# locations:
#
# - 'wildcard hack/%' checks for the service file in the 'hack'
#   directory.
#
# - 'wildcard %' checks for the service file in the current directory.
#
# Possible invocations:
#
# $ make -C hack -f Makefile.debug
# $ make -f hack/Makefile.debug
#
# or within the hack directory itself as:
#
# $ make -f Makefile.debug
$(SYSTEMD_DIR)/%: $(wildcard hack/%) $(wildcard %) | $(SYSTEMD_DIR)
	@test -f $(or $(wildcard hack/$*), $(wildcard $*)) || { echo "Error: $* not found."; exit 1; }
	install -m 644 $(or $(wildcard hack/$*), $(wildcard $*)) $@
	systemctl --user daemon-reload
	systemctl --user enable --now $*

$(SYSTEMD_DIR):
	@mkdir -p $@
